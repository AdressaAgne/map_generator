(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
console.log('video');
require('../../../src/js/libs/Video');
},{"../../../src/js/libs/Video":5}],2:[function(require,module,exports){
let id = 0;

module.exports = class Captons {

    constructor(options) {
        this.video = options.video;
        this.vtt = options.vtt;
        this.container = options.container;
        this.hidden = false;

        // Track
        this.track = document.createElement('track');
        this.track.id = `track-${++id}`;
        this.track.kind = options.kind;
        this.track.label = "Tekst";
        this.track.src = this.vtt;
        this.track.default = true;
        this.track.srclang = options.srclang;

        this.video.appendChild(this.track);

        let TextTrack = this.video.textTracks[0];
        TextTrack.mode = 'hidden';
        TextTrack.oncuechange = e => {
            for (let i = 0; i < TextTrack.activeCues.length; i++) {
                const cue = TextTrack.activeCues[i];
                this.empty();
                this.draw(cue);
            }
        };
    }

    empty() {
        this.container.innerHTML = '';
    }


    draw(cue) {
        if (this.hidden) return;

        let span = document.createElement('span');
        span.setAttribute('data-caption', cue.text);
        //span.innerHTML = `<span>${cue.text}</span>`;

        this.container.appendChild(span);
    }

    static Factory(options) {
        if (options.video instanceof Array) {
            let caps = [];
            options.video.forEach(video => {
                caps.push(new Captons({
                    video: video,
                    vtt: options.vtt,
                    container: options.container,
                    kind: options.kind || 'captions',
                    srclang : options.srclang
                }));
            });
            return caps;
        }

        return new Captons(options);
    }

}
},{}],3:[function(require,module,exports){
/**
 * Usage:
 * 
 * let responsiveVideo = require('./ResponsiveVideo').Factory();
 * 
 */
const Orientation = require('../events/Orientation');
const _debounce = require('../functions/Debounce');
const log = console.log;

let defaults = {

    directionParam: '{dir}',
    orientations: {
        portrait: '-tall',
        landscape: '-wide'
    },

    sizeParam: '{size}',
    videoSizeAttr: 'data-size',
    sizes: {
        small: '-small',
        big: '-big',
    },

    containerName: 'ratio',
    activeElementClass: 'active',
    videoPlaceholderAttr: 'data-src',
    videoOrientaionAttr: 'data-orientation',
    attributesAllowed: ['muted', 'playsinline', 'loop', 'controls', 'crossorigin'],
    attributesActive: ['controls'],

    // Func == true Small else Big
    resizeAttributeFunc: width => width >= 640,
    resizeAttributeSmallClass: 'data-ratio-small',
    resizeAttributeSmallDefault: '',
    resizeAttributeBigClass: 'data-ratio-big',
    resizeAttributeBigDefault: '',
}

module.exports = class ResponsiveVideo extends Orientation {

    constructor(selector = 'div[data-video-src]', options = {}) {
        super();

        this.defaults = Object.assign(defaults, options);
        this.videos = [];
        this.elements = [];
        this.middleware = [];

        this.size = this.currentSize();

        document.querySelectorAll(selector).forEach(video => {
            this.elements.push(this.replace(video));
        });

        this.orientationChange();
        this.resizeChange();

        this.on('change', this.orientationChange.bind(this));
        window.addEventListener('resize', _debounce(this.resizeChange.bind(this), 100));
    }

    /**
     * 
     * @param {function} middleware 
     */
    static Factory(selector = 'video[data-src]', options = {}) {

        if (typeof selector == 'object') {
            options = selector;
            selector = 'video[data-src]';
        }

        let rv = new ResponsiveVideo(selector, options);


        return rv;
    }

    /**
     * on window resize
     * @param {Event} e 
     */
    resizeChange(e) {
        this.elements.forEach(video => {

            let small = video.resizeAttributeSmallClass !== null ? video.resizeAttributeSmallClass : this.defaults.resizeAttributeSmallDefault;
            let big = video.resizeAttributeBigClass !== null ? video.resizeAttributeBigClass : this.defaults.resizeAttributeBigDefault;

            let check = this.defaults.resizeAttributeFunc(window.innerWidth);

            if (big !== "" && small !== "") {
                video.classList.remove(check ? small : big);
                video.classList.add(!check ? small : big);
            }

            if (video.hasSize && video.size !== this.currentSize()) {
                video.size = this.currentSize();
                this.emit('size', {
                    size: this.currentSize(),
                    element: video
                });
                this.swapSize(video, this.currentSize());
            }
        });
    }


    /**
     * On Orientation change Event
     */
    orientationChange() {
        this.elements.forEach(video => {
            if (video.hasOrientation) {
                this.emit('dir', {
                    orientation: this.orientation,
                    element: video
                });
                this.swapOrientation(video, this.currentOrientation());
            }
        });
    }

    /**
     * Bring a video to the front
     * @param {HTMLVideoElement} video
     */
    bringToFront(video) {
        [...video.parentNode.children].forEach(child => {
            child.style.opacity = 0;
        });
        video.style.opacity = 1;
    }

    /**
     * Swap videos to play what correspends to the current Orientation
     * @param {video container} element 
     * @param {callbackfunc} compare(video) 
     */
    swapOrientation(element, orientation) {
        // console.log('swapOrientation');
        this.swap(element, video => video.getAttribute(this.defaults.videoOrientaionAttr) == orientation);
    }

    /**
     * Swap videos to play what correspends to the current size
     * @param {video container} element 
     * @param {callbackfunc} compare(video) 
     */
    swapSize(element, size) {
        this.swap(element, video => video.getAttribute(this.defaults.videoSizeAttr) == size);
    }

    /**
     * swap a video with the current active.
     * @param {video container} element 
     * @param {callbackfunc} compare(video) 
     */
    swap(element, compare) {
        const videos = element.querySelectorAll('video');
        const active = element.querySelector(`.${this.defaults.activeElementClass}`) || videos[0];
        let isPlaying = !active.paused;

        videos.forEach(video => {
            if (compare(video)) {
                video.classList.add(this.defaults.activeElementClass);
                video.currentTime = active.currentTime;

                if (isPlaying) {
                    let promise = video.play();
                }

                this.bringToFront(video);
            } else {
                video.pause();
                video.classList.remove(this.defaults.activeElementClass);
            }
        });
    }


    /**
     * Get the current page orientation name
     */
    currentOrientation() {
        return this.defaults.orientations[this.orientation];
    }

    /**
     * Get the current size
     */
    currentSize() {
        return window.innerWidth <= 640 ? this.defaults.sizes.small : this.defaults.sizes.big;
    }

    /**
     * change the video source
     * @param {Video Source} str
     */
    changeVideoSource(str, dir = null, param) {
        return str.replace(param, dir ? dir : this.currentOrientation());
    }

    /**
     * replace the DOM element with Videor element
     * @param {HTMLElement} elm
     */
    replace(elm) {
        const div = this.createPlaceholderElement(elm);
        elm.parentNode.replaceChild(div, elm);

        elm.newElement = div;

        return div;
    }
    /**
     * Get Allowed attributes
     */
    getAllowedAttributes(element, check = this.defaults.attributesAllowed) {
        return Object.keys(element.attributes).map(key => {
            const attr = element.attributes[key].name;
            const value = element.attributes[key].value;
            if (check.indexOf(attr) > -1) {
                return {
                    key: attr,
                    value
                };
            }
            return false;
        }).filter(attr => attr !== false);
    }

    createVideo(source, value, param, attr, attrs, attrsActive, compare) {
        const video = document.createElement('video');
        video.src = this.changeVideoSource(source, value, param);
        video.setAttribute(attr, value);
        /**
         * Set the allowed attributes
         */
        attrs.forEach(item => video.setAttribute(item.key, item.value == undefined ? item.key : item.value));
        if (video.getAttribute('muted') == 'muted') {
            video.muted = true;
        }
        video.style.opacity = 0;
        /**
         * Add active class if its the current orientation
         */
        if (this[compare]() == value) {
            video.className = this.defaults.activeElementClass;
            attrsActive.forEach(attr => video.setAttribute(attr, attr));
            video.currentTime = 0;
            //video.play();
            video.style.opacity = 1;
        }

        /**
         * Append to container
         */
        return video
    }

    /**
     * Create a placeholder element for the videoContainer
     * @param {HTMLElement} originalElement
     */
    createPlaceholderElement(originalElement) {
        let div = document.createElement('div');
        div.className = `${this.defaults.containerName} ${originalElement.className}`.trim();

        div.resizeAttributeBigClass = originalElement.getAttribute(this.defaults.resizeAttributeBigClass);
        div.resizeAttributeSmallClass = originalElement.getAttribute(this.defaults.resizeAttributeSmallClass);

        const source = originalElement.getAttribute(this.defaults.videoPlaceholderAttr);
        const attrs = this.getAllowedAttributes(originalElement);
        const attrsActive = this.getAllowedAttributes(originalElement, this.defaults.attributesActive);

        if (source == null) {
            console.error(`[${this.defaults.videoPlaceholderAttr}] can not be null`);
        }

        //log(source);

        // Add video based on Orientation
        if (source.indexOf(this.defaults.directionParam) > -1) {

            div.hasOrientation = true;

            Object.keys(this.defaults.orientations).forEach(orientation => {
                /**
                 * Append to container
                 */
                let video = this.createVideo(source, this.defaults.orientations[orientation], this.defaults.directionParam, this.defaults.videoOrientaionAttr, attrs, attrsActive, 'currentOrientation');
                div.appendChild(video);
                this.videos.push(video);
            });
        }

        // Add video based on size

        if (source.indexOf(this.defaults.sizeParam) > -1) {

            div.hasSize = true;

            Object.keys(this.defaults.sizes).forEach(size => {
                /**
                 * Append to container
                 */
                let video = this.createVideo(source, this.defaults.sizes[size], this.defaults.sizeParam, this.defaults.videoSizeAttr, attrs, attrsActive, 'currentSize');
                div.appendChild(video);
                this.videos.push(video);
            });
        }


        div.muted = function () {
            return this.querySelector('video.active').muted;
        }

        div.duration = function () {
            return this.querySelector('video.active').duration;
        }

        div.currentTime = function () {
            return this.querySelector('video.active').currentTime;
        }

        div.play = function () {
            this.querySelector('video.active').play();
        }

        div.pause = function () {
            this.querySelector('video.active').pause();
        }

        div.setTime = function (float) {
            div.querySelectorAll('video').forEach(video => {
                video.currentTime = float;
            });
        }

        div.load = function() {
            div.querySelectorAll('video').forEach(video => {
                video.load();
            });
        }

        div.abort = function() {
            div.querySelectorAll('video').forEach(video => {
                video.preload = 'none';

                let s = video.src;
                let t = video.currentTime;

                video.pause();
                video.src = '';
                video.load();

                video.src = s;
                video.currentTime = t;
            });
        }

        div.querySelectorAll('video').forEach(video => {
            video.ontimeupdate = e => {
                if (typeof div.ontimeupdate == 'function') {
                    div.ontimeupdate(e);
                }
            }
        });

        return div;
    }

}
},{"../events/Orientation":7,"../functions/Debounce":8}],4:[function(require,module,exports){
const Event = require('../events/Event');

module.exports = class Slider extends Event {

    /**
     * 
     * All params optional
     * @param {HTMLElement} element 
     * @param {Float} value 
     * @param {Float} min 
     * @param {Float} max 
     * @param {Float} step 
     */
    constructor(element = null, value = 0, min = 0, max = 100, step = 1.0) {
        super();

        this.element = element == null ? this.generate() : element;

        this.min = min == NaN ? 0 : min;
        this.max = max == NaN ? 100 : max;
        this.step = step;
        this.value = value;

        this.mousedown = false;

        this.element.element.addEventListener('mousedown', this.down.bind(this));
        this.element.element.addEventListener('touchstart', this.down.bind(this));

        window.addEventListener('mouseup', this.up.bind(this));
        window.addEventListener('touchend', this.up.bind(this));

        window.addEventListener('mousemove', this.move.bind(this));
        window.addEventListener('touchmove', this.move.bind(this));

    }

    /**
     * a factory to make Sliders
     */
    static Factory() {
        return new Slider();
    }

    /**
     * Get the generated element / the passed element constructor
     */
    getElm() {
        return this.element.element;
    }

    generate() {
        let element = document.createElement('span');
        element.className = 'progress-bar';

        let time = document.createElement('span');
        time.className = 'time';
        time.textContent = '00:00';

        let played = document.createElement('span');
        played.className = 'played';
        played.style.width = '0%';

        let scrubber = document.createElement('span');
        scrubber.className = 'scrubber';

        element.appendChild(time);
        element.appendChild(played);
        played.appendChild(scrubber);

        return {
            element,
            time,
            played,
            scrubber
        };
    }

    static getOffset(el) {
        var _x = 0;
        var _y = 0;
        while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
            _x += el.offsetLeft - el.scrollLeft;
            _y += el.offsetTop - el.scrollTop;
            el = el.offsetParent;
        }
        return {
            top: _y,
            left: _x
        };
    }

    down(e) {
        this.mousedown = true;
        this.element.element.setAttribute('dirty', 'dirty');

        let x = (e.pageX == undefined) ? e.touches[0].pageX : e.pageX;

        let percent = (x - Slider.getOffset(this.element.element).left) / this.element.element.clientWidth * 100;

        this.setPercent(percent);

        this.element.element.setAttribute('mode', 'active');

        this.emit('start', {slider : this});
    }

    up(e) {
        this.mousedown = false;
        this.element.element.setAttribute('mode', 'static');

        this.emit('end', {slider : this});
    }

    move(e) {
        if (this.mousedown) {
            let x = (e.pageX == undefined) ? e.touches[0].pageX : e.pageX;
            let left = (x - Slider.getOffset(this.element.element).left) / this.element.element.clientWidth * 100;
            this.setPercent(left);
        }
    }

    getValue() {
        return this.value;
    }

    getPercent() {
        return ((this.value - this.min) * 100) / (this.max - this.min);
    }

    setPercent(percent, evt = true) {
        percent = percent < 0 ? 0 : percent;
        percent = percent > 100 ? 100 : percent;

        this.value = ((percent * (this.max - this.min) / 100) + this.min);

        this.element.played.style.width = `${percent}%`;
        this.element.element.setAttribute('data-value', this.value);

        this.setTime();

        if(evt) this.emit('change', {slider : this});
    }

    setValue(value, evt = true) {
        this.value = value < this.min ? this.min : value;
        this.value = value > this.max ? this.max : value;

        let percent = this.getPercent();

        this.element.played.style.width = `${percent}%`;
        this.element.element.setAttribute('data-value', this.value);

        this.setTime();

        if(evt) this.emit('change', {slider : this});
    }

    setTime() {
        this.element.time.textContent = `${this.getTime(this.value)} / ${this.getTime(this.max)}`;
    }

    getTime(totalSeconds) {
        let h = Math.floor(totalSeconds / 3600);
        totalSeconds %= 3600;
        let m = Math.floor(totalSeconds / 60);
        let s = parseInt(totalSeconds % 60);

        m = (m+"").padStart(2, "0");
        s = (s+"").padStart(2, "0");

        return (
            h > 0 ? (`${h}:${m}:${s}`) : (`${m}:${s}`)
        );
    }

}
},{"../events/Event":6}],5:[function(require,module,exports){
/**
 * Usage:
 * require('./libs/Video');
 * 
 */
const Captions = require('./Captions');
const Slider = require('./Slider');

let responsiveVideo = require('./ResponsiveVideo').Factory({
    attributesAllowed: ['muted', 'playsinline', 'loop', 'controls', 'data-cc', 'data-gui', 'crossorigin']
});

let captions = [];

responsiveVideo.on('load', e => {
    responsiveVideo.elements.forEach(ratio => {
        if (ratio.children[0].getAttribute('data-gui') == null) {
            // // Autoplay in viewport if viewportchecker is set on window.
            if (window.vp) {
                window.vp.add(ratio, (elm, options) => options.add ? elm.play() : elm.pause(), '0');
            }
            return;
        }
        // Autoplay in viewport if viewportchecker is set on window.
        if (window.vp) {
            window.vp.add(ratio, (elm, options) => options.add ? elm.play() : elm.pause(), '50%', {
                reverseOffset: true
            });
        }

        let figcaption = document.createElement('figcaption');
        ratio.parentNode.appendChild(figcaption);

        let nav = document.createElement('nav');
        nav.className = 'controls';
        ratio.parentNode.appendChild(nav);

        let rewind = document.createElement('a');
        rewind.className = 'rewind';
        nav.appendChild(rewind);

        let soundToggle = document.createElement('a');
        soundToggle.className = 'sound-toggle';
        nav.appendChild(soundToggle);


        let slider = new Slider();
        ratio.parentNode.appendChild(slider.getElm());
        ratio.ontimeupdate = e => {
            slider.max = ratio.duration();
            slider.setValue(ratio.currentTime(), false);

            if (slider.getPercent() > 95) {
                ratio.parentNode.classList.add('finished');
            } else {
                ratio.parentNode.classList.remove('finished');
            }
        }

        slider.on('change', e => {
            ratio.setTime(slider.value);
        });

        if (ratio.children[0].getAttribute('data-cc')) {
            // Add the TextTracks
            let cap = Captions.Factory({
                video: [...ratio.children],
                vtt: ratio.children[0].getAttribute('data-cc'),
                container: figcaption,
                srclang: 'no'
            });
            cap.forEach(c => captions.push(c));
        }


        soundToggle.addEventListener('click', e => {
            mute(!ratio.muted());
        });

        rewind.addEventListener('click', e => {
            ratio.setTime(0);
            ratio.parentNode.classList.remove('finished');
            captions.forEach(caption => {
                caption.empty();
            });
        });
    });
});


function mute(muted = true) {
    responsiveVideo.videos.forEach(video => {
        video.muted = muted;
    });
    responsiveVideo.elements.forEach(ratio => ratio.parentNode.classList[muted ? 'add' : 'remove']('muted'));
}
mute();

module.exports = responsiveVideo;
},{"./Captions":2,"./ResponsiveVideo":3,"./Slider":4}],6:[function(require,module,exports){
/**
 * Used to manage events in classes
 */


// set EventArray class _evtContainer
class Event {

    /**
     * Event init, define event container
     * @method constructor
     */
    constructor() {
        this._evtContainer = {};

        this.fireEvent = this.emit.bind(this);
        this.dispatch = this.emit.bind(this);
        this.addEventListener = this.on.bind(this);
        this.removeEventListener = this.off.bind(this);

        setTimeout(() => this.fireEvent('load'), 0);
    }

    /**
     * Fire an event
     * @method fireEvent
     * @param  {String}  evt   [Event name]
     * @param  {Object}  param [function bind]
     * @return {void}
     */
    emit(evt, param) {
        // Does the event exist
        if (!this.has(evt)) return false;

        this.get(evt).forEach(callback => {
            // Call callback functions if it exists
            if (callback && typeof callback === 'function') {
                let e = Object.assign((param || {}), {
                    _type: evt,
                    _emitter: this.constructor.name,
                    _off: () => this.delete(evt, callback),
                    _callback: callback
                });
                callback.bind(this)(e);
            }
        });

        return this;
    }

    /**
     * Set event functions
     * @method on
     * @param  {Event}    evts     [event names]
     * @param  {Function} callback [callback]
     * @return {this}
     */
    on(evts, callback = null) {
        if (typeof callback !== 'function') throw Error('Callback must be a function');

        let event_array = evts.split(' ');
        for (let i = 0; i < event_array.length; i++) {
            const evt = event_array[i];

            this.create(evt).add(evt, callback);
        }
        return this;
    }


    /**
     * Remove event function
     * @param {String} events
     * @param {Callback} function
     */
    off(evts, callback = null) {
        console.log(evts, callback);
        let event_array = evts.split(' ');
        for (let i = 0; i < event_array.length; i++) {
            const evt = event_array[i];

            callback !== null ? this.delete(evt, callback) : this.reset(evt);
        }

    }

    /**
     * Get an EventContainer
     * @param {String} evt 
     */
    get(evt) {
        return this._evtContainer[evt];
    }

    /**
     * check if event exists
     * @param {String} evt 
     */
    has(evt) {
        return this.get(evt) !== undefined && this.get(evt) instanceof Map;
    }

    /**
     * Add an event to an EventContainer
     * @param {String} evt 
     * @param {Function} callback 
     */
    add(evt, callback) {
        this.get(evt).set(callback, callback);

        if (this.get(evt).size > Event.MAX_LISTENERS) {
            console.warn(`Event ${evt} has more then ${Event.MAX_LISTENERS} listeners. (You can change Event.MAX_LISTENERS)`);
        }

        return this;
    }

    /**
     * Create Event container if it does not exist
     * @param {String} evt 
     */
    create(evt) {
        if (this.has(evt)) return this;

        this._evtContainer[evt] = new Map();

        return this;
    }

    /**
     * Reset an EventContainer to null
     * @param {String} evt 
     */
    reset(evt) {
        if (!this.has(evt)) return this;

        this._evtContainer[evt] = new Map();

        return this;

    }

    /**
     * Delete an EventContainer
     * @param {String} evt 
     */
    delete(evt, callback) {
        if (evt && callback && !this.has(evt) && this.get(evt).has(callback)) return this;

        this.get(evt).delete(callback);

        return this;
    }

}


let max_listeners = 10;
/**
 * Define Event vars, and set setters
 */
Object.defineProperties(Event, {

    MIN_MAX_LISTENERS: {
        value: 1,
        writable: false
    },

    MAX_LISTENERS: {
        set(value) {
            if (typeof value != 'number') throw new Error('Event.MAX_LISTENERS must be typeof Number, got ' + typeof value);

            if (value < Event.MIN_MAX_LISTENERS) throw new Error(`Event.MAX_LISTENERS should be abow ${Event.MIN_MAX_LISTENERS}`);

            max_listeners = value;
        },
        get() {
            return max_listeners;
        }
    }

});

/**
 * Export Event class
 */
module.exports = Event;
},{}],7:[function(require,module,exports){
/**
 * Usage:
 * let orientation = require('./libs/events/Orientation').Factory();
 * orientation.on('portrait', e => {
 *  // code
 * });
 * 
 * orientation.on('landscape', e => {
 *  // code
 * });
 * 
 * orientation.on('change', e => {
 *  // code
 * });
 * 
 * OR
 * 
 * class example extends Orientation {
 *  constructor(){
 *      super()
 * 
 *      this.on('portrait', e => {
 *          // code
 *      })
 *  }
 * }
 * 
 */


const Event = require('./Event.js');

module.exports = class Orientation extends Event {

    /**
     * Events:
     * portrait,
     * landscape,
     * change,
     */
    constructor() {
        super();

        let mql = window.matchMedia("(orientation: portrait)");
        // If there are matches, we're in portrait
        this.orientation = mql.matches ?
            'portrait' :
            'landscape';

        // Add a media query change listener
        mql.addListener(e => {
            this.orientation = e.matches ?
                'portrait' :
                'landscape';

            e.matches ?
                this.emit('portrait', {orientation : this.orientation}) :
                this.emit('landscape', {orientation : this.orientation});

            this.emit('change', {orientation : this.orientation});
        });
    }

    static Factory() {
        return new Orientation();
    }
}
},{"./Event.js":6}],8:[function(require,module,exports){
/**
 * Usage:
 * const _debounce = require('./libs/functions/Debounce');
 * _debounce(callback, wait, immediate)
 */

// Credit David Walsh (https://davidwalsh.name/javascript-debounce-function)

// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.

module.exports = function debounce(func, wait, immediate) {
  var timeout;

  return function executedFunction() {
    var context = this;
    var args = arguments;
	    
    var later = function() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    var callNow = immediate && !timeout;
	
    clearTimeout(timeout);

    timeout = setTimeout(later, wait);
	
    if (callNow) func.apply(context, args);
  };
}
},{}]},{},[1]);
